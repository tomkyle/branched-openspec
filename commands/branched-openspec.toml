description = "Run the OpenSpec workflow in a dedicated Git work branch while guiding the user through each stage."
prompt = """


# Tasks

1. Derive a branch name from the requirement and create/check out the work
   branch before touching files.
1. Run `/openspec-proposal`, `/openspec-apply`, and `/openspec-archive`
   sequentially, guiding the user through each stage.
1. After archiving, offer to merge back into the base branch, delete the work
   branch locally, and skip any push to origin.

# Git Commands

Autonomous commands are limited to:

- `git checkout -b <work-branch>`
- `git add <directory>`
- `git commit --message "<message>"`
- `git checkout <base-branch>`
- `git merge -m "chore(spec): merge <work-branch>"`
  `--no-ff <work-branch>`
- `git branch -d <work-branch>`

# Rules

You must follow these rules strictly:

## 1. Branching

- Always branch from `HEAD` before starting work.
- Name the branch after the task or referenced user story (e.g., `feature-...`,
  `fix-...`).
- When `/userstories/` is involved, read the file as the baseline but never edit
  or move it.
- Direct commits to the base branch are forbidden; use the work branch.

## 2. Commit Message Structure (Conventional Commits)

```text
<type>(<scope>): <description>

[optional body]

OpenSpec phase: <phase>
[optional additional footers]
```

| Type   | Description                  | SemVer |
|--------|------------------------------|--------|
| feat   | New feature                  | MINOR |
| fix    | Bug fix                      | PATCH |
| docs   | Docs only                    | None  |
| style  | Formatting only              | None  |
| refactor | Internal rework            | None  |
| perf   | Performance improvement      | None  |
| test   | Tests                        | None  |
| build  | Build system / deps          | None  |
| ci     | Continuous integration       | None  |
| chore  | Spec lifecycle / maintenance | None  |
| revert | Revert prior commit          | None  |

Breaking changes must add `!` after type/scope and a
`BREAKING CHANGES:` footer to signal a MAJOR release.

## 3. OpenSpec Lifecycle Commits

Commit right after each OpenSpec phase, pause for user confirmation, and absorb
any user commits made in between.

If security settings prevent automatic commits, instruct the user to run the
commands manually and list them.

- **Proposal**: When the spec and `openspec/project.md` are updated, commit
  `chore(spec): propose [feature-name]`, summarise spec edits (reference
  `/userstories/...` if used), add `OpenSpec phase: proposal`, and remind
  the user they can refine before Apply.
- **Apply**: After implementation passes required tests, commit
  `feat|fix|refactor([scope]): implement [feature-name]`, describe how the
  code meets the spec, append `OpenSpec phase: apply`, and prompt for
  review/refinement before Archive.
- **Archive**: Once archived and tasks close, commit
  `chore(spec): archive [feature-name]` with a short summary plus
  `OpenSpec phase: archive`. Offer to merge and delete the work branch via
  `git checkout [base] && git merge -m "chore(spec): merge [work]"`
  `--no-ff [work] && git branch -d [work]`.

## 4. Test Gate

- Never commit with failing tests.
- Run test suites in order, if they exist: Unit -> Integration -> Functional ->
  E2E, fixing failures before progressing.
- When tests fail, share the output and propose a fix instead of committing.

## 5. Conflict Handling

1. Stop and analyse; never delete markers blindly.
1. Resolve trivial conflicts, escalate logical ones to the user.
1. Preserve human edits unless explicitly overruled.
1. Re-run tests before completing the merge.

## 6. General

- Fold in any user commits you find, regardless of formatting.
- Offer `git reset --hard [last-stable-hash]` for recovery and reread
  `project.md` after resets or branch switches.
- Treat `/userstories/` as immutable input unless told otherwise.

# Raw Requirement Input

{{args}}
"""
